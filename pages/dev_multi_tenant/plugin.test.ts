import payload, { CollectionSlug } from 'payload'
import { afterAll, beforeAll, describe, expect, test } from 'vitest'
import config from './src/payload.config'
import type { Page, Tenant, Config } from 'payload/generated-types'

// NOTE: this file only contains test that are specific to the multi-tenant setup. The main plugin tests are located in the /dev project.

/**
 * Empty virtual fields that are generated by the plugin.
 * Spread this into data objects when creating documents to satisfy TypeScript.
 */
const virtualFields = {
  breadcrumbs: [],
  path: '',
}

type DefaultIDType = Config['db']['defaultIDType']

beforeAll(async () => {
  await payload.init({
    config: config,
  })

  // clear all collections except users
  await deleteAllCollections(['users'])
})

afterAll(async () => {
  if (payload.db && typeof payload.db.destroy === 'function') {
    await payload.db.destroy()
  } else {
    console.log('Could not destroy database')
  }
})

describe('Multi-tenant baseFilter functionality', () => {
  let tenant1Id: DefaultIDType
  let tenant2Id: DefaultIDType

  beforeAll(async () => {
    // Create two tenants
    const tenant1 = await payload.create({
      collection: 'tenants',
      data: {
        slug: 'tenant-1',
        name: 'Tenant 1',
        websiteUrl: 'https://tenant1.example.com',
      },
    })
    tenant1Id = tenant1.id

    const tenant2 = await payload.create({
      collection: 'tenants',
      data: {
        slug: 'tenant-2',
        name: 'Tenant 2',
        websiteUrl: 'https://tenant2.example.com',
      },
    })
    tenant2Id = tenant2.id
  })

  describe('Pages isolation between tenants', () => {
    test('Root page creation respects tenant isolation', async () => {
      // Create root pages for both tenants
      const rootPage1 = await payload.create({
        collection: 'pages',
        data: {
          title: 'Tenant 1 Home',
          slug: '',
          content: 'Tenant 1 home content',
          isRootPage: true,
          tenant: tenant1Id,
          ...virtualFields,
        },
      })

      const rootPage2 = await payload.create({
        collection: 'pages',
        data: {
          title: 'Tenant 2 Home',
          slug: '',
          content: 'Tenant 2 home content',
          isRootPage: true,
          tenant: tenant2Id,
          ...virtualFields,
        },
      })

      // Verify both root pages were created with the same slug
      expect(rootPage1.slug).toBe('')
      expect(rootPage2.slug).toBe('')
      expect((rootPage1.tenant as Tenant).id).toBe(tenant1Id)
      expect((rootPage2.tenant as Tenant).id).toBe(tenant2Id)
    })

    test('Pages with same slug can exist in different tenants', async () => {
      // Create pages with the same slug for both tenants
      const page1 = await payload.create({
        collection: 'pages',
        data: {
          title: 'About Us - Tenant 1',
          slug: 'about',
          content: 'About tenant 1',
          tenant: tenant1Id,
          ...virtualFields,
        },
      })

      const page2 = await payload.create({
        collection: 'pages',
        data: {
          title: 'About Us - Tenant 2',
          slug: 'about',
          content: 'About tenant 2',
          tenant: tenant2Id,
          ...virtualFields,
        },
      })

      // Verify both pages were created with the same slug
      expect(page1.slug).toBe('about')
      expect(page2.slug).toBe('about')
      expect((page1.tenant as Tenant).id).toBe(tenant1Id)
      expect((page2.tenant as Tenant).id).toBe(tenant2Id)
    })

    test('Parent field respects tenant isolation', async () => {
      // Create parent pages for both tenants
      const parentPage1 = await payload.create({
        collection: 'pages',
        data: {
          title: 'Products - Tenant 1',
          slug: 'products',
          content: 'Products for tenant 1',
          tenant: tenant1Id,
          ...virtualFields,
        },
      })

      const parentPage2 = await payload.create({
        collection: 'pages',
        data: {
          title: 'Products - Tenant 2',
          slug: 'products',
          content: 'Products for tenant 2',
          tenant: tenant2Id,
          ...virtualFields,
        },
      })

      // Create child pages
      const childPage1 = await payload.create({
        collection: 'pages',
        data: {
          title: 'Product A',
          slug: 'product-a',
          content: 'Product A details',
          parent: parentPage1.id,
          tenant: tenant1Id,
          ...virtualFields,
        },
      })

      const childPage2 = await payload.create({
        collection: 'pages',
        data: {
          title: 'Product B',
          slug: 'product-b',
          content: 'Product B details',
          parent: parentPage2.id,
          tenant: tenant2Id,
          ...virtualFields,
        },
      })

      // Verify parent relationships
      expect((childPage1.parent as Page).id).toBe(parentPage1.id)
      expect((childPage2.parent as Page).id).toBe(parentPage2.id)
      expect((childPage1.tenant as Tenant).id).toBe(tenant1Id)
      expect((childPage2.tenant as Tenant).id).toBe(tenant2Id)
    })
  })

  describe('Breadcrumbs and paths respect tenant isolation', () => {
    test('Breadcrumbs and paths are correctly generated', async () => {
      // Setup: Create hierarchical pages for tenant 1
      const rootPageT1 = await payload.create({
        collection: 'pages',
        data: {
          title: 'Services',
          slug: 'services',
          content: 'Services page',
          tenant: tenant1Id,
          ...virtualFields,
        },
      })

      const childPageT1 = await payload.create({
        collection: 'pages',
        data: {
          title: 'Consulting',
          slug: 'consulting',
          content: 'Consulting services',
          parent: rootPageT1.id,
          tenant: tenant1Id,
          ...virtualFields,
        },
      })

      // Setup: Create similar hierarchy for tenant 2
      const rootPageT2 = await payload.create({
        collection: 'pages',
        data: {
          title: 'Services',
          slug: 'services',
          content: 'Services page T2',
          tenant: tenant2Id,
          ...virtualFields,
        },
      })

      const childPageT2 = await payload.create({
        collection: 'pages',
        data: {
          title: 'Development',
          slug: 'development',
          content: 'Development services',
          parent: rootPageT2.id,
          tenant: tenant2Id,
          ...virtualFields,
        },
      })

      // Fetch pages with breadcrumbs
      const fetchedChildT1 = await payload.findByID({
        collection: 'pages',
        id: childPageT1.id,
      })

      const fetchedChildT2 = await payload.findByID({
        collection: 'pages',
        id: childPageT2.id,
      })

      // Verify breadcrumbs are tenant-specific
      expect(fetchedChildT1.breadcrumbs).toHaveLength(2)
      expect(fetchedChildT1.breadcrumbs[0].label).toBe('Services')
      expect(fetchedChildT1.breadcrumbs[1].label).toBe('Consulting')

      expect(fetchedChildT2.breadcrumbs).toHaveLength(2)
      expect(fetchedChildT2.breadcrumbs[0].label).toBe('Services')
      expect(fetchedChildT2.breadcrumbs[1].label).toBe('Development')

      // Paths should be correctly generated
      expect(fetchedChildT1.path).toBe('/services/consulting')
      expect(fetchedChildT2.path).toBe('/services/development')
    })

    test('Cross-collection breadcrumbs and paths are correctly generated', async () => {
      // Create author overview pages for both tenants
      const authorPageT1 = await payload.create({
        collection: 'pages',
        data: {
          title: 'Authors T1',
          slug: 'authors',
          content: 'Authors overview T1',
          tenant: tenant1Id,
          ...virtualFields,
        },
      })

      const authorPageT2 = await payload.create({
        collection: 'pages',
        data: {
          title: 'Writers T2',
          slug: 'writers',
          content: 'Writers overview T2',
          tenant: tenant2Id,
          ...virtualFields,
        },
      })

      // Create authors in different tenants
      const author1 = await payload.create({
        collection: 'authors',
        data: {
          name: 'Author One',
          slug: 'author-one',
          content: 'Bio of author one',
          parent: authorPageT1.id,
          tenant: tenant1Id,
          ...virtualFields,
        },
      })

      const author2 = await payload.create({
        collection: 'authors',
        data: {
          name: 'Author Two',
          slug: 'author-two',
          content: 'Bio of author two',
          parent: authorPageT2.id,
          tenant: tenant2Id,
          ...virtualFields,
        },
      })

      // Verify breadcrumbs respect tenant boundaries
      const fetchedAuthor1 = await payload.findByID({
        collection: 'authors',
        id: author1.id,
      })

      const fetchedAuthor2 = await payload.findByID({
        collection: 'authors',
        id: author2.id,
      })

      expect(fetchedAuthor1.breadcrumbs[0].label).toBe('Authors T1')
      expect(fetchedAuthor1.path).toBe('/authors/author-one')

      expect(fetchedAuthor2.breadcrumbs[0].label).toBe('Writers T2')
      expect(fetchedAuthor2.path).toBe('/writers/author-two')
    })
  })

  describe('Redirects validation respects tenant isolation', () => {
    test('Redirect validation only checks within the same tenant', async () => {
      // Create redirect for tenant 1
      const redirect1 = await payload.create({
        collection: 'redirects',
        data: {
          sourcePath: '/old-page',
          destinationPath: '/new-page',
          type: 'permanent',
          tenant: tenant1Id,
        },
      })

      // Should be able to create the same redirect for tenant 2
      const redirect2 = await payload.create({
        collection: 'redirects',
        data: {
          sourcePath: '/old-page',
          destinationPath: '/new-page',
          type: 'permanent',
          tenant: tenant2Id,
        },
      })

      expect(redirect1.sourcePath).toBe('/old-page')
      expect(redirect2.sourcePath).toBe('/old-page')
      expect((redirect1.tenant as Tenant).id).toBe(tenant1Id)
      expect((redirect2.tenant as Tenant).id).toBe(tenant2Id)
    })

    test('Redirect loop detection only checks within the same tenant', async () => {
      // Create bidirectional redirects in tenant 1 (should fail)

      // First create the 'forward' redirect
      await payload.create({
        collection: 'redirects',
        data: {
          sourcePath: '/page-a',
          destinationPath: '/page-b',
          type: 'permanent',
          tenant: tenant1Id,
        },
      })

      // Then create the 'backward' redirect. This should fail for tenant 1
      await expect(
        payload.create({
          collection: 'redirects',
          data: {
            sourcePath: '/page-b',
            destinationPath: '/page-a',
            type: 'permanent',
            tenant: tenant1Id,
          },
        }),
      ).rejects.toThrow()

      // But creating the same 'backward' redirect should work in tenant 2
      const backwardsRedirectTenant2 = await payload.create({
        collection: 'redirects',
        data: {
          sourcePath: '/page-b',
          destinationPath: '/page-a',
          type: 'permanent',
          tenant: tenant2Id,
        },
      })

      expect(backwardsRedirectTenant2.sourcePath).toBe('/page-b')
      expect((backwardsRedirectTenant2.tenant as Tenant).id).toBe(tenant2Id)
    })
  })
})

/**
 * Helper function to delete all documents from a collection.
 */
const deleteCollection = async (collection: CollectionSlug) => {
  // use db.deleteMany instead of payload.delete to avoid running hooks
  await payload.db.deleteMany({
    collection: collection,
    where: {},
  })

  // this will fail for collections which have no versions enabled, therefore wrapped in a try catch
  try {
    await payload.db.deleteVersions({
      collection: collection,
      where: {},
    })
  } catch {}
}

/**
 * Deletion order for collections to respect foreign key constraints.
 * Collections are deleted in this order: children before parents.
 * Collections not in this list will be deleted at the end in arbitrary order.
 */
const COLLECTION_DELETION_ORDER: CollectionSlug[] = [
  // Level 3: deepest nested (depends on level 2)
  'country-travel-tips',
  // Level 2: depends on level 1 collections
  'blogposts',
  'authors',
  'countries',
  'redirects',
  // Level 1: root collections (pages can self-reference)
  'pages',
  // Level 0: no dependencies
  'blogpost-categories',
  'tenants',
]

const deleteAllCollections = async (except: CollectionSlug[] = []) => {
  const collections = (await config).collections?.filter((c) => !except.includes(c.slug)) ?? []
  const collectionSlugs = new Set(collections.map((c) => c.slug))

  // Delete in the specified order first
  for (const slug of COLLECTION_DELETION_ORDER) {
    if (collectionSlugs.has(slug)) {
      await deleteCollection(slug)
      collectionSlugs.delete(slug)
    }
  }

  // Delete any remaining collections not in the order list
  for (const slug of Array.from(collectionSlugs)) {
    await deleteCollection(slug)
  }
}
