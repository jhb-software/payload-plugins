import payload, { CollectionSlug, ValidationError } from 'payload'
import { afterAll, beforeAll, beforeEach, describe, expect, test } from 'vitest'
import config from './src/payload.config'

// NOTE: this file contains a subset of the tests from the localized (/dev) project which are adjusted to test in a unlocalized environment.

/**
 * Empty virtual fields that are generated by the plugin.
 * Spread this into data objects when creating documents to satisfy TypeScript.
 */
const virtualFields = {
  breadcrumbs: [],
  path: '',
}

beforeAll(async () => {
  await payload.init({
    config: config,
  })

  // clear all collections except users
  await deleteAllCollections(['users'])
})

afterAll(async () => {
  if (payload.db && typeof payload.db.destroy === 'function') {
    await payload.db.destroy()
  } else {
    console.log('Could not destroy database')
  }
})

describe('Path and breadcrumb virtual fields are returned correctly for find operation.', () => {
  describe('The root page document', () => {
    beforeEach(async () => await deleteCollection('pages'))

    test('has the correct virtual fields', async () => {
      const rootPageData = {
        title: 'Root Page',
        slug: '',
        content: 'Root Page',
        isRootPage: true,
      }

      const rootPageId = (
        await payload.create({
          collection: 'pages',
          data: { ...rootPageData, ...virtualFields },
        })
      ).id

      const rootPage = await payload.findByID({
        collection: 'pages',
        id: rootPageId,
      })

      const path = `/`

      expect(rootPage.slug).toBe('') // Plugin convention: The slug of the root page is an empty string.
      expect(rootPage.path).toBe(path)
      expect(removeIdsFromArray(rootPage.breadcrumbs)).toEqual(
        removeIdsFromArray([
          {
            id: undefined,
            path,
            label: rootPageData.title,
            slug: rootPageData.slug,
          },
        ]),
      )
    })
  })

  describe('Nested document in same collection.', () => {
    const rootPageData = {
      title: 'Root Page',
      slug: 'root-page',
      content: 'Root Page',
    }
    const nestedPageData = {
      title: 'Nested Page',
      slug: 'nested-page',
      content: 'Nested Page',
    }
    let rootPageId: string | number | undefined // will be set in the beforeEach hook
    let nestedPageId: string | number | undefined // will be set in the beforeEach hook

    beforeAll(async () => {
      await deleteCollection('pages')

      // ################# Seed the database for the tests of this group #################

      rootPageId = (
        await payload.create({
          collection: 'pages',
          data: { ...rootPageData, ...virtualFields },
        })
      ).id

      await payload.update({
        collection: 'pages',
        id: rootPageId,
        data: { ...rootPageData, ...virtualFields },
      })

      nestedPageId = (
        await payload.create({
          collection: 'pages',
          data: { ...nestedPageData, parent: rootPageId, ...virtualFields },
        })
      ).id

      await payload.update({
        collection: 'pages',
        id: nestedPageId,
        data: { ...nestedPageData, parent: rootPageId, ...virtualFields },
      })
    })

    describe('Breadcrumbs', () => {
      test('are correctly set when requested.', async () => {
        const nestedPage = await payload.findByID({
          collection: 'pages',
          id: nestedPageId!,
        })

        expect(nestedPage).toBeDefined()

        // Breadcrumbs must be an array
        expect(Array.isArray(nestedPage.breadcrumbs)).toBe(true)

        // Breadcrumbs must be correctly set
        expect(nestedPage.breadcrumbs).toStrictEqual([
          {
            id: nestedPage.breadcrumbs[0]?.id,
            label: rootPageData.title,
            slug: rootPageData.slug,
            path: `/${rootPageData.slug}`,
          },
          {
            id: nestedPage.breadcrumbs[1]?.id,
            label: nestedPageData.title,
            slug: nestedPageData.slug,
            path: `/${rootPageData.slug}/${nestedPageData.slug}`,
          },
        ])
      })
    })

    describe('Path', () => {
      test('is correctly set when requested.', async () => {
        const nestedPage = await payload.findByID({
          collection: 'pages',
          id: nestedPageId!,
        })

        expect(nestedPage).toBeDefined()
        expect(nestedPage.path).toBeDefined()
        expect(typeof nestedPage.path).toBe('string')

        expect(nestedPage.path).toStrictEqual(`/${rootPageData.slug}/${nestedPageData.slug}`)
      })
    })
  })

  describe('Nested document in same collection.', () => {
    const rootPageData = {
      title: 'Root Page',
      slug: 'root-page',
      content: 'Root Page',
    }
    const nestedPageData = {
      title: 'Nested Page',
      slug: 'nested-page',
      content: 'Nested Page',
    }
    let rootPageId: string | number | undefined // will be set in the beforeEach hook
    let nestedPageId: string | number | undefined // will be set in the beforeEach hook

    beforeAll(async () => {
      await deleteCollection('pages')

      // ################# Seed the database for the tests of this group #################

      rootPageId = (
        await payload.create({
          collection: 'pages',
          data: { ...rootPageData, ...virtualFields },
        })
      ).id

      nestedPageId = (
        await payload.create({
          collection: 'pages',
          data: { ...nestedPageData, parent: rootPageId, ...virtualFields },
        })
      ).id
    })

    describe('Breadcrumbs', () => {
      test('are correctly set when requested.', async () => {
        const nestedPage = await payload.findByID({
          collection: 'pages',
          id: nestedPageId!,
        })

        expect(nestedPage).toBeDefined()

        // Breadcrumbs must be an array
        expect(Array.isArray(nestedPage.breadcrumbs)).toBe(true)

        // Breadcrumbs must be correctly set
        expect(nestedPage.breadcrumbs).toStrictEqual([
          {
            id: nestedPage.breadcrumbs[0]?.id,
            label: rootPageData.title,
            slug: rootPageData.slug,
            path: `/${rootPageData.slug}`,
          },
          {
            id: nestedPage.breadcrumbs[1]?.id,
            label: nestedPageData.title,
            slug: nestedPageData.slug,
            path: `/${rootPageData.slug}/${nestedPageData.slug}`,
          },
        ])
      })
    })

    describe('Path', () => {
      test('is correctly set when requested.', async () => {
        const nestedPage = await payload.findByID({
          collection: 'pages',
          id: nestedPageId!,
        })

        expect(nestedPage).toBeDefined()
        expect(nestedPage.path).toBeDefined()
        expect(typeof nestedPage.path).toBe('string')

        expect(nestedPage.path).toStrictEqual(`/${rootPageData.slug}/${nestedPageData.slug}`)
      })
    })
  })

  test('Nested document across collections.', async () => {
    const authorOverviewPageData = {
      title: 'Authors',
      slug: 'authors',
      content: 'Authors page',
    }
    const authorPageData = {
      name: 'Test Author',
      slug: 'test-author',
      content: 'Test Author',
    }

    const authorOverviewPageId = (
      await payload.create({
        collection: 'pages',
        data: { ...authorOverviewPageData, ...virtualFields },
      })
    ).id

    const authorPageId = (
      await payload.create({
        collection: 'authors',
        data: { ...authorPageData, parent: authorOverviewPageId, ...virtualFields },
      })
    ).id

    // Verify the author was created and linked correctly
    const author = await payload.findByID({
      collection: 'authors',
      depth: 0,
      id: authorPageId,
    })

    expect(author).toBeDefined()
    expect(author.parent).toBe(authorOverviewPageId)

    // Verify path is correctly set
    expect(author.path).toBe(`/${authorOverviewPageData.slug}/${authorPageData.slug}`)

    // Verify breadcrumbs are correctly set
    expect(author.breadcrumbs).toBeDefined()
    expect(removeIdsFromArray(author.breadcrumbs)).toEqual([
      {
        label: authorOverviewPageData.title,
        path: `/${authorOverviewPageData.slug}`,
        slug: authorOverviewPageData.slug,
      },
      {
        label: authorPageData.name,
        path: `/${authorOverviewPageData.slug}/${authorPageData.slug}`,
        slug: authorPageData.slug,
      },
    ])
  })
})

describe('Path and breadcrumb virtual fields are set correctly for find operation with select.', () => {
  test('Only path and breadcrumbs are selected (not slug etc.)', async () => {
    const pageId = (
      await payload.create({
        collection: 'pages',
        data: {
          title: 'Page',
          slug: 'page',
          content: 'Page',
          ...virtualFields,
        },
      })
    ).id

    const pageWithSelect = await payload.findByID({
      collection: 'pages',
      id: pageId,
      select: {
        path: true,
        breadcrumbs: true,
        alternatePaths: true,
      },
    })

    const pageWithoutSelect = await payload.findByID({
      collection: 'pages',
      id: pageId,
    })

    // Breadcrumbs must be an array
    expect(Array.isArray(pageWithSelect.breadcrumbs)).toBe(true)

    // Breadcrumbs array should match homePage breadcrumbs
    expect(removeIdsFromArray(pageWithSelect.breadcrumbs)).toEqual(
      removeIdsFromArray(pageWithoutSelect.breadcrumbs),
    )

    // Path must be defined and non-empty
    expect(pageWithSelect.path).toBeDefined()

    // Path must be defined and non-empty
    expect(pageWithSelect.path).toEqual(pageWithoutSelect.path)
  })
})

describe('Slug field behaves as expected for create and update operations', () => {
  test('Slug remains unchanged when title is updated', async () => {
    // Create initial page
    const initialData = {
      title: 'Initial Title',
      content: 'Some content',
      slug: 'initial-title',
    }

    const page = await payload.create({
      collection: 'pages',
      data: { ...initialData, ...virtualFields },
    })

    expect(page.slug).toBe('initial-title')

    // Update the title
    const updatedPage = await payload.update({
      collection: 'pages',
      id: page.id,
      data: {
        title: 'Updated Title',
      },
    })

    // Verify slug remains unchanged
    expect(updatedPage.slug).toBe('initial-title')
    expect(updatedPage.title).toBe('Updated Title')
  })

  test('Validation Error is thrown when creating a page without providing a slug', async () => {
    // Create page without providing a slug
    const pageData = {
      title: 'Test Page Title',
      content: 'Some content',
    }

    try {
      await payload.create({
        collection: 'pages',
        data: {
          ...pageData,
          slug: undefined as unknown as string, // Force missing slug to test validation
          ...virtualFields,
        },
      })
    } catch (error) {
      expect(error).toBeInstanceOf(ValidationError)
    }
  })

  test('Validation Error is thrown when creating a page with an invalid slug', async () => {
    // Create page without providing a slug
    const pageData = {
      title: 'Test Page Title 2',
      content: 'Some content 2',
      slug: 'invalid slug &!=',
    }

    try {
      await payload.create({
        collection: 'pages',
        data: { ...pageData, ...virtualFields },
      })
    } catch (error) {
      expect(error).toBeInstanceOf(ValidationError)
    }
  })

  test('Validation Error is thrown when trying to create a root page without providing a slug', async () => {
    // Create initial root page without providing a slug
    const initialData = {
      title: 'Root Page',
      content: 'Root page content',
      isRootPage: true,
    }

    try {
      await payload.create({
        collection: 'pages',
        data: {
          ...initialData,
          slug: undefined as unknown as string, // Force missing slug to test validation
          ...virtualFields,
        },
      })
    } catch (error) {
      expect(error).toBeInstanceOf(ValidationError)
    }
  })

  test('Root page is created sucessfully with an empty slug and throws validation error when slug is updated', async () => {
    // Delete any existing root page
    await payload.delete({
      collection: 'pages',
      where: {
        slug: { equals: '' },
      },
    })

    // Create initial root page without providing a slug
    const initialData = {
      title: 'Root Page',
      content: 'Root page content',
      isRootPage: true,
      slug: '',
    }

    const rootPage = await payload.create({
      collection: 'pages',
      data: { ...initialData, ...virtualFields },
    })

    // Verify the slug is empty
    expect(rootPage.slug).toBe('')
    expect(rootPage.isRootPage).toBe(true)

    // Try to update the slug
    try {
      await payload.update({
        collection: 'pages',
        id: rootPage.id,
        data: {
          slug: 'attempted-slug',
        },
      })
    } catch (error) {
      expect(error).toBeInstanceOf(ValidationError)
    }
  })
})

/**
 * Helper function to remove id field from objects in an array
 */
const removeIdsFromArray = <T extends { id?: any }>(array: T[]): Omit<T, 'id'>[] => {
  return array.map(({ id, ...rest }) => rest)
}

/**
 * Helper function to delete all documents from a collection.
 */
const deleteCollection = async (collection: CollectionSlug) => {
  // use db.deleteMany instead of payload.delete to avoid running hooks
  await payload.db.deleteMany({
    collection: collection,
    where: {},
  })

  // this will fail for collections which have no versions enabled, therefore wrapped in a try catch
  try {
    await payload.db.deleteVersions({
      collection: collection,
      where: {},
    })
  } catch {}
}

/**
 * Deletion order for collections to respect foreign key constraints.
 * Collections are deleted in this order: children before parents.
 * Collections not in this list will be deleted at the end in arbitrary order.
 */
const COLLECTION_DELETION_ORDER: CollectionSlug[] = [
  // Level 3: deepest nested (depends on level 2)
  'country-travel-tips',
  // Level 2: depends on level 1 collections
  'blogposts',
  'authors',
  'countries',
  // Level 1: root collections (pages can self-reference)
  'pages',
  // Level 0: no dependencies
  'blogpost-categories',
  'redirects',
]

const deleteAllCollections = async (except: CollectionSlug[] = []) => {
  const collections = (await config).collections?.filter((c) => !except.includes(c.slug)) ?? []
  const collectionSlugs = new Set(collections.map((c) => c.slug))

  // Delete in the specified order first
  for (const slug of COLLECTION_DELETION_ORDER) {
    if (collectionSlugs.has(slug)) {
      await deleteCollection(slug)
      collectionSlugs.delete(slug)
    }
  }

  // Delete any remaining collections not in the order list
  for (const slug of Array.from(collectionSlugs)) {
    await deleteCollection(slug)
  }
}
